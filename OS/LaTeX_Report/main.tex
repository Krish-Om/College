\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}

% Code listing settings
\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=5pt,
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showstringspaces=false,
    captionpos=b
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Operating System Laboratory Work}
\fancyhead[R]{\today}
\fancyfoot[C]{\thepage}

% Title formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\title{\textbf{Operating System Laboratory Work Report}}
\author{[Your Name] \\ [Your Roll Number] \\ [Your Department]}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This report presents a comprehensive implementation and analysis of fundamental Operating System algorithms. The laboratory work covers four major areas: CPU Scheduling Algorithms, Deadlock Avoidance using Banker's Algorithm, Page Replacement Algorithms, and Memory Allocation strategies. A total of 13 programs have been implemented in C programming language, demonstrating practical understanding of core Operating System concepts. Each implementation includes detailed analysis, performance metrics, and comparative studies to provide insights into algorithm behavior and efficiency.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}

Operating Systems form the foundation of modern computing systems, managing hardware resources and providing essential services to applications. This laboratory work focuses on implementing and analyzing key algorithms that form the core of operating system functionality.

The objectives of this laboratory work are:
\begin{itemize}
    \item To understand and implement various CPU scheduling algorithms
    \item To demonstrate deadlock avoidance mechanisms
    \item To analyze page replacement strategies in virtual memory systems
    \item To compare different memory allocation techniques
    \item To evaluate algorithm performance through quantitative analysis
\end{itemize}

\section{Lab 1: CPU Scheduling Algorithms}

\subsection{Objective}
CPU scheduling is fundamental to multiprogramming operating systems. The goal is to maximize CPU utilization while ensuring fair resource allocation among processes. This lab implements four different scheduling algorithms and compares their performance characteristics.

\subsection{Algorithms Implemented}

\subsubsection{First Come First Serve (FCFS)}
\textbf{File:} \texttt{lab1.1.c}

FCFS is the simplest scheduling algorithm where processes are executed in the order of their arrival. It is non-preemptive and easy to implement.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Non-preemptive scheduling
    \item Fair in terms of arrival order
    \item May suffer from convoy effect
    \item Simple implementation with minimal overhead
\end{itemize}

\textbf{Test Case:}
\begin{itemize}
    \item Processes: 4
    \item Arrival Times: [0, 1, 2, 3]
    \item Burst Times: [5, 3, 8, 6]
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/fcfs_output.png}
    \caption{FCFS Scheduling Algorithm Output}
    \label{fig:fcfs_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Shortest Job First (SJF)}
\textbf{File:} \texttt{lab1.2.c}

SJF scheduling selects the process with the smallest burst time for execution. This algorithm provides optimal average waiting time.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Optimal average waiting time
    \item Non-preemptive implementation
    \item Requires advance knowledge of burst times
    \item May cause starvation for longer processes
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/sjf_output.png}
    \caption{SJF Scheduling Algorithm Output}
    \label{fig:sjf_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Round Robin (RR)}
\textbf{File:} \texttt{Lab1.3.c}

Round Robin is a preemptive scheduling algorithm that allocates CPU time in fixed time slices (quantum) to each process in circular order.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Preemptive scheduling
    \item Fair CPU time allocation
    \item Good response time for interactive systems
    \item Performance depends on time quantum selection
\end{itemize}

\textbf{Test Case:}
\begin{itemize}
    \item Processes: 4
    \item Burst Times: [5, 3, 1, 4]
    \item Time Quantum: 2
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/rr_output.png}
    \caption{Round Robin Scheduling Algorithm Output}
    \label{fig:rr_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Priority Scheduling}
\textbf{File:} \texttt{Lab1.4.c}

Priority scheduling executes processes based on their assigned priorities, with higher priority processes executed first.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Non-preemptive priority-based execution
    \item Allows critical processes to execute first
    \item May cause priority inversion
    \item Risk of starvation for low-priority processes
\end{itemize}

\textbf{Test Case:}
\begin{itemize}
    \item Processes: 4
    \item Burst Times: [5, 1, 6, 7]
    \item Priorities: [3, 1, 4, 2] (1 = highest priority)
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/priority_output.png}
    \caption{Priority Scheduling Algorithm Output}
    \label{fig:priority_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsection{Performance Analysis}

\begin{table}[H]
\centering
\caption{CPU Scheduling Algorithms Comparison}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Algorithm} & \textbf{Avg WT} & \textbf{Avg TAT} & \textbf{Complexity} & \textbf{Starvation} \\
\hline
FCFS & - & - & O(1) & No \\
\hline
SJF & - & - & O(n²) & Yes \\
\hline
Round Robin & - & - & O(1) & No \\
\hline
Priority & - & - & O(n²) & Yes \\
\hline
\end{tabular}
\label{tab:cpu_scheduling_comparison}
\end{table}

% Space for filling performance metrics
\vspace{2cm}

\section{Lab 2: Deadlock Avoidance (Banker's Algorithm)}

\subsection{Objective}
Deadlock is a critical issue in multiprogramming systems where processes wait indefinitely for resources. The Banker's Algorithm provides a deadlock avoidance mechanism by ensuring the system remains in a safe state.

\subsection{Algorithm Implementation}

\subsubsection{Complete Banker's Algorithm}
\textbf{File:} \texttt{banker.c}

This implementation provides a comprehensive Banker's Algorithm with resource request handling and safety checking.

\textbf{Key Components:}
\begin{itemize}
    \item Allocation Matrix: Resources currently allocated to processes
    \item Max Matrix: Maximum resource requirements of processes
    \item Available Vector: Currently available resources
    \item Need Matrix: Remaining resource requirements (Max - Allocation)
\end{itemize}

\textbf{Safety Algorithm:}
\begin{enumerate}
    \item Initialize Work = Available and Finish[i] = false for all i
    \item Find process i such that Finish[i] = false and Need[i] ≤ Work
    \item Work = Work + Allocation[i] and Finish[i] = true
    \item Repeat until all processes are finished or no such process exists
\end{enumerate}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/banker_output.png}
    \caption{Complete Banker's Algorithm Output}
    \label{fig:banker_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Simplified Banker's Algorithm}
\textbf{File:} \texttt{tiny\_banker.c}

A streamlined implementation focusing on safety sequence determination with hardcoded matrices for demonstration purposes.

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/tiny_banker_output.png}
    \caption{Simplified Banker's Algorithm Output}
    \label{fig:tiny_banker_output}
\end{figure}

% Space for manual output insertion
\vspace{2cm}

\subsection{Algorithm Analysis}
The Banker's Algorithm ensures deadlock-free execution by:
\begin{itemize}
    \item Maintaining system in safe state
    \item Checking resource requests before allocation
    \item Providing rollback mechanism for unsafe requests
    \item Guaranteeing completion of all processes
\end{itemize}

\section{Lab 3: Page Replacement Algorithms}

\subsection{Objective}
Virtual memory systems use page replacement algorithms to manage limited physical memory efficiently. This lab implements and compares three fundamental page replacement strategies.

\subsection{Algorithms Implemented}

\subsubsection{FIFO Page Replacement}
\textbf{File:} \texttt{lab3\_4.c}

First-In-First-Out replaces the oldest page in memory, implementing a simple queue-based strategy.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Simple queue-based implementation
    \item Easy to understand and implement
    \item May suffer from Belady's anomaly
    \item Independent of page access patterns
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/fifo_page_output.png}
    \caption{FIFO Page Replacement Algorithm Output}
    \label{fig:fifo_page_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{LRU Page Replacement}
\textbf{File:} \texttt{lru\_page\_replacement.c}

Least Recently Used replaces the page that has not been accessed for the longest time, exploiting temporal locality.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Exploits temporal locality principle
    \item Better performance than FIFO
    \item Requires tracking of access timestamps
    \item More complex implementation
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/lru_page_output.png}
    \caption{LRU Page Replacement Algorithm Output}
    \label{fig:lru_page_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Optimal Page Replacement}
\textbf{File:} \texttt{optimal\_page\_replacement.c}

The optimal algorithm replaces the page that will not be used for the longest time in the future, providing theoretical minimum page faults.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Theoretical minimum page faults
    \item Requires future knowledge of page references
    \item Impractical for real systems
    \item Benchmark for other algorithms
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/optimal_page_output.png}
    \caption{Optimal Page Replacement Algorithm Output}
    \label{fig:optimal_page_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsection{Performance Comparison}

\begin{table}[H]
\centering
\caption{Page Replacement Algorithms Comparison}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Algorithm} & \textbf{Page Faults} & \textbf{Hit Ratio} & \textbf{Complexity} & \textbf{Practical} \\
\hline
FIFO & - & - & O(1) & Yes \\
\hline
LRU & - & - & O(n) & Yes \\
\hline
Optimal & - & - & O(n²) & No \\
\hline
\end{tabular}
\label{tab:page_replacement_comparison}
\end{table}

% Space for filling performance metrics
\vspace{2cm}

\section{Lab 4: Memory Allocation Algorithms}

\subsection{Objective}
Dynamic memory allocation is crucial for efficient memory management. This lab implements three allocation strategies and analyzes their fragmentation characteristics.

\subsection{Algorithms Implemented}

\subsubsection{First Fit Allocation}
\textbf{File:} \texttt{first\_fit.c}

First Fit allocates the first available memory block that is large enough to satisfy the request.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Fast allocation (stops at first suitable block)
    \item Simple implementation
    \item May cause external fragmentation
    \item Good for systems with frequent allocation/deallocation
\end{itemize}

\textbf{Test Case:}
\begin{itemize}
    \item Memory Blocks: [500, 200, 300, 600]
    \item Process Sizes: [212, 417, 112, 426]
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/first_fit_output.png}
    \caption{First Fit Memory Allocation Output}
    \label{fig:first_fit_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Best Fit Allocation}
\textbf{File:} \texttt{best\_fit.c}

Best Fit allocates the smallest available block that can satisfy the request, minimizing wasted space.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Minimizes internal fragmentation
    \item Searches entire free list
    \item Better memory utilization
    \item Slower allocation due to search overhead
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/best_fit_output.png}
    \caption{Best Fit Memory Allocation Output}
    \label{fig:best_fit_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsubsection{Worst Fit Allocation}
\textbf{File:} \texttt{worst\_fit.c}

Worst Fit allocates the largest available block, leaving the largest possible hole after allocation.

\textbf{Algorithm Characteristics:}
\begin{itemize}
    \item Leaves larger holes after allocation
    \item May reduce external fragmentation in some cases
    \item Generally poor performance
    \item Simple to implement
\end{itemize}

\textbf{Output:}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{code_outputs/worst_fit_output.png}
    \caption{Worst Fit Memory Allocation Output}
    \label{fig:worst_fit_output}
\end{figure}

% Space for manual output insertion
\vspace{3cm}

\subsection{Fragmentation Analysis}

\begin{table}[H]
\centering
\caption{Memory Allocation Algorithms Comparison}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Algorithm} & \textbf{Internal Frag.} & \textbf{Allocation Time} & \textbf{Memory Util.} & \textbf{Performance} \\
\hline
First Fit & - & Fast & Moderate & Good \\
\hline
Best Fit & - & Slow & High & Better \\
\hline
Worst Fit & - & Slow & Low & Poor \\
\hline
\end{tabular}
\label{tab:memory_allocation_comparison}
\end{table}

% Space for filling fragmentation data
\vspace{2cm}

\section{Compilation and Execution}

\subsection{Build Instructions}
All programs can be compiled using the provided build script:

\begin{lstlisting}[language=bash, caption=Build Script Execution]
chmod +x build_all.sh
./build_all.sh
\end{lstlisting}

\subsection{Individual Compilation}
Programs can also be compiled individually:

\begin{lstlisting}[language=bash, caption=Individual Compilation Commands]
# CPU Scheduling
gcc -g -Wall lab1.1.c -o bin/fcfs
gcc -g -Wall lab1.2.c -o bin/sjf
gcc -g -Wall Lab1.3.c -o bin/round_robin
gcc -g -Wall Lab1.4.c -o bin/priority

# Banker's Algorithm
gcc -g -Wall banker.c -o bin/banker
gcc -g -Wall tiny_banker.c -o bin/tiny_banker

# Page Replacement
gcc -g -Wall lab3_4.c -o bin/fifo
gcc -g -Wall lru_page_replacement.c -o bin/lru
gcc -g -Wall optimal_page_replacement.c -o bin/optimal

# Memory Allocation
gcc -g -Wall first_fit.c -o bin/first_fit
gcc -g -Wall best_fit.c -o bin/best_fit
gcc -g -Wall worst_fit.c -o bin/worst_fit
\end{lstlisting}

\section{Results and Analysis}

\subsection{Key Findings}

\subsubsection{CPU Scheduling}
\begin{itemize}
    \item FCFS provides simplicity but may cause convoy effect
    \item SJF offers optimal average waiting time but requires burst time knowledge
    \item Round Robin ensures fairness with time quantum dependency
    \item Priority scheduling allows process importance handling
\end{itemize}

\subsubsection{Deadlock Avoidance}
\begin{itemize}
    \item Banker's Algorithm successfully prevents deadlocks
    \item Safety checking ensures system stability
    \item Resource allocation becomes conservative but safe
\end{itemize}

\subsubsection{Page Replacement}
\begin{itemize}
    \item FIFO is simple but suffers from Belady's anomaly
    \item LRU provides good practical performance
    \item Optimal serves as theoretical benchmark
\end{itemize}

\subsubsection{Memory Allocation}
\begin{itemize}
    \item First Fit offers speed advantage
    \item Best Fit minimizes fragmentation
    \item Worst Fit generally performs poorly
\end{itemize}

\subsection{Performance Metrics Summary}

% Space for comprehensive performance summary table
\vspace{4cm}

\section{Conclusion}

This laboratory work has successfully demonstrated the implementation and analysis of fundamental Operating System algorithms. Through practical implementation, we have gained insights into:

\begin{itemize}
    \item Trade-offs between different scheduling strategies
    \item Importance of deadlock prevention mechanisms
    \item Virtual memory management techniques
    \item Memory allocation efficiency considerations
\end{itemize}

The implemented algorithms provide a solid foundation for understanding Operating System internals and can serve as reference implementations for further study and development.

\subsection{Future Enhancements}
Potential areas for extension include:
\begin{itemize}
    \item Implementation of disk scheduling algorithms
    \item Advanced synchronization mechanisms
    \item File system allocation methods
    \item Real-time scheduling algorithms
\end{itemize}

\section{References}

\begin{itemize}
    \item Silberschatz, A., Galvin, P. B., \& Gagne, G. (2018). \textit{Operating System Concepts}. John Wiley \& Sons.
    \item Tanenbaum, A. S., \& Bos, H. (2014). \textit{Modern Operating Systems}. Pearson.
    \item Stallings, W. (2018). \textit{Operating Systems: Internals and Design Principles}. Pearson.
\end{itemize}

\end{document}
